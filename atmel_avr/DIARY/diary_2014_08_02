TODO
- blink_led
  - [ok] modifier le programme pour faire clignoter la LED embarquée de l'Arduino
    - [ok] sur le duemilanove, la led est sur D13 (PB5/SCK en notation AVR)
  - [ok] téléverser le dernier .hex dans le m328p via un arduino en ISP
  - [ok] vérifier avec "avrdude -t dump"/"avrdude -U ..r..." que le contenu est le même que le code du .hex
  - [ok] faire clignoter la LED embarquée de l'Arduino
  - [ok] mesurer les tensions de sortie ? -> ATTENTION: brancher le voltmètre en dérivation, pas en série !!!
    - [ok] sur l'arduino, aux bornes de la led -> 1.85V
    - [ok] sur la breadboard, aux bornes de la led -> 1.9V
    - [ok] sur la breadboard, aux bornes de la led + résistance -> 5V => OK!
  - [ok] faire le montage de test hors Arduino
  - [ok] refaire le tout en programmant hors de l'arduino
  - [no,usbasp only] tester avec les autres programmeurs
  - [ok] tester avec d'autres MCU
- Makefile
- digital input (push button)
- [ok] tester blinkled sur le pololu 3Pi
- faire le shema ou prendre des photos des montages (programmation et utilisation) avec fritzing
- [ok] logical operators for bits manipulation in C
- étiquettes
- souder prise usb
- souder ICS 10pins -> 6pins

- read
  http://www.micahcarrick.com/tutorials/avr-microcontroller-tutorial/getting-started.html
  http://en.wikipedia.org/wiki/Intel_HEX
  http://elecrom.wordpress.com/2008/02/12/avr-tutorial-2-avr-input-output/
  http://www.evilmadscientist.com/2012/blink-an-led-with-an-avr/
  http://www.evilmadscientist.com/2007/using-avr-microcontrollers-minimalist-target-boards/
  http://www.ladyada.net/learn/proj1/blinky.html
  http://www.toddholoubek.com/classes/pcomp/?page_id=692
- learn pull-up / pull-down resistor
  http://makezine.com/2009/03/05/understanding-pullup-and-pulldown-r/
  http://www.youritronics.com/atmega8-protostack-simple-demo/
  http://en.wikipedia.org/wiki/Pull-up_resistor
  https://learn.sparkfun.com/tutorials/pull-up-resistors
  https://learn.sparkfun.com/tutorials/pull-up-resistors/what-is-a-pull-up-resistor
  http://fr.wikipedia.org/wiki/R%C3%A9sistance_de_rappel
  http://playground.arduino.cc/CommonTopics/PullUpDownResistor
  http://wiki.t-o-f.info/Arduino/R%C3%A9sistanceDeRappel
  http://www.seattlerobotics.org/encoder/mar97/basics.html
  http://www.bit-101.com/blog/?p=3813
- fuses: comment les programmer avec avrdude
  [ok] http://www.ladyada.net/learn/avr/fuses.html
- registres
  [ok] http://blog.cicatrice.eu/47
  http://blog.cicatrice.eu/119
- vecteurs d'initialisation -> quoi qu'est-ce ?
  -> semble avoir un rapport avec les interruptions
  http://en.wikipedia.org/wiki/Interrupt_vector_table
- interruptions
  read docs/avr_interrupts.pdf
       docs/hill/...
       http://blog.cicatrice.eu/
- PENSER À RAMENER LE CABLE USB-SERIAL DU RPi, LE ROBOT 3PI, LE PROGRAMMEUR 3PI, LA PINCE POUR MCU, L'ARDUINO ET QUELQUES MCU ATMEGA168/328(P) !!!


NOTE ABOUT man avrdude:

+ The available memory types are device-dependent, the actual configuration can
  be viewed with the "part" command in terminal mode.
     > part

*   *  -U memtype:op:filename[:format]

       Perform a memory operation as indicated.  The memtype field specifies
       the memory type to operate on.  The available memory types are
       device-dependent, the actual configuration can be viewed with the part
       command in terminal mode.  Typically, a device's memory configuration at
       least contains the memory types flash and eeprom.  All memory types
       currently known are:

       calibration  One or more bytes of RC oscillator calibration data.
    *  eeprom       The EEPROM of the device.
    *  efuse        The extended fuse byte.
    *  flash        The flash ROM of the device.
       fuse         The fuse byte in devices that have only a single fuse byte.
    *  hfuse        The high fuse byte.
    *  lfuse        The low fuse byte.
       lock         The lock byte.
    *  signature    The three device signature bytes (device ID).
       fuseN        The fuse bytes of ATxmega devices, N is an integer number for each fuse supported by the device.
       application  The application flash area of ATxmega devices.
       apptable     The application table flash area of ATxmega devices.
       boot         The boot flash area of ATxmega devices.
       prodsig      The production signature (calibration) area of ATxmega devices.
       usersig      The user signature area of ATxmega devices.

       The op field specifies what operation to perform:

    *  r        read device memory and write to the specified file
    *  w        read data from the specified file and write to the device memory
       v        read data from both the device and the specified file and perform a verify

       The filename field indicates the name of the file to read or write.  The
       format field is optional and contains the format of the file to read or
       write.  Format can be one of:

    *  i    Intel Hex
       s    Motorola S-record
    *  r    raw binary; little-endian byte order, in the case of the flash ROM data
    *  m    immediate; actual byte values specified on the command line,
                       separated by commas or spaces.  This is good for programming fuse bytes
                       without having to create a single-byte file or enter terminal mode.
       a    auto detect; valid for input only, and only if the input is not provided at stdin.
       d    decimal; this and the following formats are only valid on output.
                     They generate one line of output for the respective memory section,
                     forming a comma-separated list of the values.  This can be particularly
                     useful for subsequent processing, like for fuse bit settings.
    *  h    hexadecimal; each value will get the string 0x prepended.
       o    octal; each value will get a 0 prepended unless it is less than 8 in which case it gets no prefix.
    *  b    binary; each value will get the string 0b prepended.

       The default is to use auto detection for input files, and raw binary
       format for output files. Note that if filename contains a colon, the
       format field is no longer optional since the filename part following the
       colon would otherwise be misinterpreted as format.

       As an abbreviation, the form -U filename is equivalent to specifying
       -U flash:w:filename:a. This will only work if filename does not have a
       colon in it.

+ Terminal mode
  In this mode, avrdude only initializes communication with the MCU, and then
  awaits user commands on standard input.  Commands and parameters may be
  abbreviated to the shortest unambiguous form.  Terminal mode provides a
  command history using readline(3), so previously entered command lines can be
  recalled and edited.  The following commands are currently implemented:

  *  dump memtype addr nbytes
             Read nbytes bytes from the specified memory area, and display them
             in the usual hexadecimal and ASCII form.

  +  dump    Continue dumping the memory contents for another nbytes where the
             previous dump command left off.

     write memtype addr byte1 ... byteN
             Manually program the respective memory cells, starting at address
             addr, using the values byte1 through byteN.  This feature is not implemented
             for bank-addressed memories such as the flash memory of ATMega
             devices.

  +  erase   Perform a chip erase.

     send b1 b2 b3 b4
             Send raw instruction codes to the AVR device.  If you need access
             to a feature of an AVR part that is not directly supported by avrdude, this
             command allows you to use it, even though avrdude does not implement
             the command. When using direct SPI mode, up to 3 bytes can be omitted.

  +  sig     Display the device signature bytes.

     spi     Enter direct SPI mode.  The pgmled pin acts as slave select.  Only
             supported on parallel bitbang programmers.

  *  part    Display the current part settings and parameters.  Includes chip
             specific information including all memory types supported by the device,
             read/write timing, etc.

     pgm     Return to programming mode (from direct SPI mode).

     ?

     help    Give a short on-line summary of the available commands.

     quit    Leave terminal mode and thus avrdude.



NOTES ABOUT http://www.ladyada.net/learn/avr/avrdude.html:
+ To program the fuses, use:
    avrdude -c usbtiny -p m328p -U lfuse:w:<0xHH>:m  -U hfuse:w:<0xHH>:m  -U efuse:w:<0xHH>:m


NOTES ABOUT http://www.ladyada.net/learn/avr/fuses.html:
- The fuses define things like the clock speed, crystal type, whether JTAG is
  enabled, what the brownout (minimum voltage) level is, etc.
- Note that despite being called 'fuses' they are re-settable and dont have
  anything to do with protection from overpowering (like the fuses in a home).
+ Setting the fuses incorrectly can 'brick' the chip !!
+ http://www.engbedded.com/fusecalc/
- Fuse: External Clock
  means that a square wave is being input into the CLOCK-IN pin. This is pretty
  rare unless you have a clock generating chip. Don't use this unless you're
  sure you mean to
- Fuse: Internal Clock
  means that theres a little oscillator inside the chip, its not very precise
  but good for most projects that dont have fine timing issues. The clock
  varies with temperature and the power supply voltage. You can chose from a
  8MHz, 4MHz or 128KHz clock. The 128KHz clock is for very low power
  applications where running the chip very slowly helps conserve power. Having
  an internal oscillator means we don't need to wire up a crystal and we can
  use the clock pins for our own nefarious purposes.
+ Fuse: Clock Output
  The next option is Clock Out on PortD2 which means, basically, that whatever
  the clock input is (internal, external, crystal, etc) a square wave of the
  same frequency will appear on pin D2. This is useful if you're debugging the
  clock rate, or if you want to use the clock to drive another chip.
  By default, chips that come from the factory have this turned off.
+ Fuse: Clock Divide
  This fuse causes the chip to divide the clock rate by 8. So if the clock source
  is set to Internal 8MHz and you have this fuse set, then you'll really be
  running at 1MHz.
  By default, chips that come from the factory have this turned on.
+ Fuse: Brown-out Detect (BOD)
  These fuses set what voltage to turn the Brownout protection circuitry on.
  A brownout for a chip means that the power voltage is too low for it to run
  reliably at the speed of the clock.
  For example, the attiny2313 can run as fast at 20MHz but only if the
  powervoltage is between 4.5V and 5.5V. If the voltage is lower than that, it
  may behave erratically, erasing or overwriting the RAM and EEPROM. It may
  also start running random piece of the flash program. To keep it from doing
  that, set the brownout voltage to 4.3V, then if the voltage dips, the chip
  will turn off until the voltage returns. It will then reset and start over.
  If the chip is meant to run at 5V, set the brown-out to 4.3V. If the chip can
  run as low as 3.3V you can set the brown-out to 1.8V. If the chip is a 'low
  voltage compatible' chip such as the attiny2313V (which can run as low as
  1.8V if its clocked at 4MHz or less) then you can set the brownout to 1.8V.
  You can read the speed and voltage grades on the front page of the datasheet.
  By default, chips that come from the factory don't have brown-out detect
  however I suggest you set it if you can. If you have a bootloader or are
  storing data in the EEPROM you must set the BOD! 


NOTES ABOUT http://riktronic.prismaticmedia.com/?p=15:
* Reading avr fuse bits with avrdude (note the minus for output file):
    -U lfuse:r:-:i -U hfuse:r:-:i -U efuse:r:-:i -U lock:r:-:i
* To match the hex format used by all the great fuse calculators out there,
  this should be used instead:
    -U lfuse:r:-:h -U hfuse:r:-:h -U efuse:r:-:h -U lock:r:-:h


NOTES ABOUT http://blog.cicatrice.eu/119 (registres):
- tiny85 -> 64 registres
- adresses des registres: 0x16 PINB 
                          0x17 DDRB 
                          0x18 PORTB 
  (véfifier si on retrouve ces codes hexa dans le fichier ASM)
+ Le registre DDRB indique les directions (entrée ou sortie) de chaque broche.
  Par défaut, les broches sont configurés en entrée (valeur 0). La valeur 1
  correspond donc à une utilisation en sortie.


NOTES ABOUT "man avr-gcc":
+ usefull options
  * -print-search-dirs       Display the directories in the compiler's search path
  + -print-libgcc-file-name  Display the name of the compiler's companion library
    -print-file-name=<lib>   Display the full path to library <lib>
    -print-prog-name=<prog>  Display the full path to compiler component <prog>
    -print-multi-directory   Display the root directory for versions of libgcc
    -print-multi-lib         Display the mapping between command line options and
                             multiple library search directories
    -print-multi-os-directory Display the relative path to OS libraries
    -print-sysroot           Display the target libraries directory
    -print-sysroot-headers-suffix Display the sysroot suffix used to find headers
  + -save-temps              Do not delete intermediate files
  + -v                       Display the programs invoked by the compiler
  + -###                     Like -v but options quoted and commands not executed
  + -E                       Preprocess only; do not compile, assemble or link
  + -S                       Compile only; do not assemble or link
  + -c                       Compile and assemble, but do not link
    -o <file>                Place the output into <file>
    ...

NOTES ABOUT AVR-GCC AND AVRLIBC:
* important paths (Ubuntu 13.04):

  AVR-GCC relative libs are in      /usr/lib/gcc/avr/4.7.2/
                                    /usr/lib/gcc/avr/4.7.2/include/
                                    /usr/lib/gcc/avr/4.7.2/avrXXX/
  AVR-STDLIB relative libs are in   /usr/lib/avr/
                                    /usr/lib/avr/include/
                                    /usr/lib/avr/lib/

  Ne pas confondre les 2 !
  Exemple:

    ls /usr/lib/gcc/avr/4.7.2/avr5
        libgcc.a  libgcov.a

    ls /usr/lib/avr/lib/avr5
        crt90pwm216.o  crtm1281.o     crtm164p.o  crtm169.o     crtm16.o     crtm3250.o   crtm3290.o   crtm32m1.o  crtm644pa.o  crtm6490.o   crtusb1286.o     libscanf_flt.a
        crt90pwm316.o  crtm1284p.o    crtm165a.o  crtm169pa.o   crtm16u4.o   crtm3250p.o  crtm3290p.o  crtm32.o    crtm644p.o   crtm649a.o   crtusb1287.o     libscanf_min.a
        crt90scr100.o  crtm128.o      crtm165.o   crtm169p.o    crtm3000.o   crtm325a.o   crtm329a.o   crtm32u4.o  crtm6450a.o  crtm649.o    crtusb646.o
        crtat94k.o     crtm128rfa1.o  crtm165p.o  crtm16a.o     crtm323.o    crtm325.o    crtm329.o    crtm32u6.o  crtm6450.o   crtm649p.o   crtusb647.o
        crtcan128.o    crtm161.o      crtm168a.o  crtm16hva2.o  crtm324a.o   crtm325p.o   crtm329pa.o  crtm406.o   crtm6450p.o  crtm64c1.o   libc.a
        crtcan32.o     crtm162.o      crtm168.o   crtm16hva.o   crtm324pa.o  crtm328.o    crtm329p.o   crtm640.o   crtm645a.o   crtm64hve.o  libm.a
        crtcan64.o     crtm163.o      crtm168p.o  crtm16hvb.o   crtm324p.o   crtm328p.o   crtm32c1.o   crtm644a.o  crtm645.o    crtm64m1.o   libprintf_flt.a
        crtm1280.o     crtm164a.o     crtm169a.o  crtm16m1.o    crtm3250a.o  crtm3290a.o  crtm32hvb.o  crtm644.o   crtm645p.o   crtm64.o     libprintf_min.a

* Exemple pour le mega328p
  /usr/lib/avr/include/avr/iom328p.h


NOTES ABOUT LOGICAL OPERATORS IN C:
+ logical operators
  AND : x & y
  OR  : x | y
  XOR : x ^ y
  NOT : ~x
  LEFT SHIFT  (N bits): x << N
  RIGHT SHIFT (N bits): x >> N
* logical operators
  x<<y  <=>  "tous les bits de x sont déplacés de y positions vers la gauche"

  Beaucoup utilisé pour faire des masques:
    (1<<DDB0)  <=>   (1<<0)  <=>  0b00000001
   ~(1<<DDB0)  <=>  ~(1<<0)  <=>  0b11111110
                                 
    (1<<DDB2)  <=>   (1<<2)  <=>  0b00000100
   ~(1<<DDB2)  <=>  ~(1<<2)  <=>  0b11111011

   set bit DDB2 (DDB2 = 2):
     PORTB |= (1<<DDB2);
   clear bit DDB2:
     PORTB &= ~(1<<DDB2);  => (PortB AND Mask) DDB2 est positioné à 0, les autres bits du portB ne changent pas
   toggle bit DDB2:
     PORTB ^=  (1<<DDB2);  => (PortB OR Mask)  DDB2 est positioné à 1, les autres bits du portB ne changent pas

NOTES:
* la tension de sortie des pins configurés "output digital" n'est pas +5V mais
  VCC !!! (ie. si l'AVR est alimenté en 4V, la tension de sortie des pins
  configurés "output digital" est de 4V)
+ la programmation par ISP ne fonctionne pas avec le "Pololu ISP programmer"
* pour USBasp la programmation par ISP ne fonctionne pas avec une source
  d'alimentation externe (testé avec 4 piles NiMh) mais fonctionne en utilisant
  les broches VCC et GND de l'USBasp... (pourquoi ?)
  En revanche, le montage une fois programmé fonctionne normalement en utilisant
  les 4 piles NiMh...

