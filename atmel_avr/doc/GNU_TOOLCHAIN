avr-gcc --terget-help
avrdude -c ?          -> list of supported programmers
avrdude -p ?          -> list of supported MCU

MCU id pour gcc-avr: attiny85

avr-gcc -g -Os -Wall -mcall-prologues -mmcu=attiny85 -c -o blink_led.o blink_led.c


aptitude install avrdude avrdude-doc binutils-avr avr-libc gcc-avr gdb-avr

  avr-libc       a subset of the Standard C Library (libc) for AVR (+ functions specific to AVR)
  gcc-avr        the GNU compiler (C/C++/Ada to ASM)
  binutils-avr   the GNU linker, assambler, ...
  avrdude        the most famous open source programmer for AVR
  gdb-avr        the GNU debuger
  fritzing       the most famous electronic design software in the Arduino comunity
  fritzing-data


AVR TOOLCHAIN
http://www.nongnu.org/avr-libc/user-manual/pages.html
(or http://www.atmel.com/webdoc/AVRLibcReferenceManual/overview.html )

avr-libc reference: http://www.nongnu.org/avr-libc/user-manual/modules.html

Detailed first example: http://www.nongnu.org/avr-libc/user-manual/group__demo__project.html#demo_project_src


avr-libc
   GCC and Binutils provides a lot of the tools to develop software, but there is one critical component that they do not provide: a Standard C Library.
   There are different open source projects that provide a Standard C Library depending upon your system time, whether for a native compiler (GNU Libc), for some other embedded system (newlib), or for some versions of Linux (uCLibc). The open source AVR toolchain has its own Standard C Library project: avr-libc.
   AVR-Libc provides many of the same functions found in a regular Standard C Library and many additional library functions that is specific to an AVR. Some of the Standard C Library functions that are commonly used on a PC environment have limitations or additional issues that a user needs to be aware of when used on an embedded system.
   AVR-Libc also contains the most documentation about the whole AVR toolchain.

GCC
GCC stands for GNU Compiler Collection. GCC is highly flexible compiler system. It has different compiler front-ends for different languages. It has many back-ends that generate assembly code for many different processors and host operating systems. All share a common "middle-end", containing the generic parts of the compiler, including a lot of optimizations.
In GCC, a host system is the system (processor/OS) that the compiler runs on. A target system is the system that the compiler compiles code for. And, a build system is the system that the compiler is built (from source code) on. If a compiler has the same system for host and for target, it is known as a native compiler. If a compiler has different systems for host and target, it is known as a cross-compiler. (And if all three, build, host, and target systems are different, it is known as a Canadian cross compiler, but we won't discuss that here.) When GCC is built to execute on a host system such as FreeBSD, Linux, or Windows, and it is built to generate code for the AVR microcontroller target, then it is a cross compiler, and this version of GCC is commonly known as "AVR GCC". In documentation, or discussion, AVR GCC is used when referring to GCC targeting specifically the AVR, or something that is AVR specific about GCC. The term "GCC" is usually used to refer to something generic about GCC, or about GCC as a whole.
GCC is different from most other compilers. GCC focuses on translating a high-level language to the target assembly only. AVR GCC has three available compilers for the AVR: C language, C++, and Ada. The compiler itself does not assemble or link the final code.
GCC is also known as a "driver" program, in that it knows about, and drives other programs seamlessly to create the final output. The assembler, and the linker are part of another open source project called GNU Binutils. GCC knows how to drive the GNU assembler (gas) to assemble the output of the compiler. GCC knows how to drive the GNU linker (ld) to link all of the object modules into a final executable.
The two projects, GCC and Binutils, are very much interrelated and many of the same volunteers work on both open source projects.
When GCC is built for the AVR target, the actual program names are prefixed with "avr-". So the actual executable name for AVR GCC is: avr-gcc. The name "avr-gcc" is used in documentation and discussion when referring to the program itself and not just the whole AVR GCC system.
See the GCC Web Site and GCC User Manual for more information about GCC.

GNU Binutils
The name GNU Binutils stands for "Binary Utilities". It contains the GNU assembler (gas), and the GNU linker (ld), but also contains many other utilities that work with binary files that are created as part of the software development toolchain.
Again, when these tools are built for the AVR target, the actual program names are prefixed with "avr-". For example, the assembler program name, for a native assembler is "as" (even though in documentation the GNU assembler is commonly referred to as "gas"). But when built for an AVR target, it becomes "avr-as". Below is a list of the programs that are included in Binutils:

avr-as
The Assembler.

avr-ld
The Linker.

avr-ar
Create, modify, and extract from libraries (archives).

avr-ranlib
Generate index to library (archive) contents.

avr-objcopy
Copy and translate object files to different formats.

avr-objdump
Display information from object files including disassembly.

avr-size
List section sizes and total size.

avr-nm
List symbols from object files.

avr-strings
List printable strings from files.

avr-strip
Discard symbols from files.

avr-readelf
Display the contents of ELF format files.

avr-addr2line
Convert addresses to file and line.

avr-c++filt
Filter to demangle encoded C++ symbols.


avr-libc
GCC and Binutils provides a lot of the tools to develop software, but there is one critical component that they do not provide: a Standard C Library.
There are different open source projects that provide a Standard C Library depending upon your system time, whether for a native compiler (GNU Libc), for some other embedded system (newlib), or for some versions of Linux (uCLibc). The open source AVR toolchain has its own Standard C Library project: avr-libc.
AVR-Libc provides many of the same functions found in a regular Standard C Library and many additional library functions that is specific to an AVR. Some of the Standard C Library functions that are commonly used on a PC environment have limitations or additional issues that a user needs to be aware of when used on an embedded system.
AVR-Libc also contains the most documentation about the whole AVR toolchain.


AVRDUDE
After creating your software, you'll want to program your device. You can do this by using the program AVRDUDE which can interface with various hardware devices to program your processor.
AVRDUDE is a very flexible package. All the information about AVR processors and various hardware programmers is stored in a text database. This database can be modified by any user to add new hardware or to add an AVR processor if it is not already listed.

